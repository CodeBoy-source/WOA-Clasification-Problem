<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Práctica de Metaheurística: Referencia del Archivo tools/Euclidean.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Práctica de Metaheurística<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">APC Clasification Problem, Greedy vs LocalSearch</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Buscar','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Buscar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4eeb864c4eec08c7d6b9d3b0352cfdde.html">tools</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">typedefs</a> &#124;
<a href="#func-members">Funciones</a>  </div>
  <div class="headertitle"><div class="title">Referencia del Archivo Euclidean.h</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;../inc/eigen-3.4.0/Eigen/Dense&quot;</code><br />
<code>#include &quot;../inc/random.hpp&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="Euclidean_8h_source.html">Ir al código fuente de este archivo.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
typedefs</h2></td></tr>
<tr class="memitem:a180f0653ebd0d5cdf633574b8c8512d3"><td class="memItemLeft" align="right" valign="top"><a id="a180f0653ebd0d5cdf633574b8c8512d3" name="a180f0653ebd0d5cdf633574b8c8512d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Random</b> = effolkronium::random_static</td></tr>
<tr class="separator:a180f0653ebd0d5cdf633574b8c8512d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Funciones</h2></td></tr>
<tr class="memitem:ad065fd64357444d7792b80876fcfa41f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8h.html#ad065fd64357444d7792b80876fcfa41f">minEuclideanDistance</a> (Eigen::RowVectorXd fixed, Eigen::MatrixXd data, Eigen::MatrixXd::Index &amp;maxRow)</td></tr>
<tr class="memdesc:ad065fd64357444d7792b80876fcfa41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data.  <a href="Euclidean_8h.html#ad065fd64357444d7792b80876fcfa41f">Más...</a><br /></td></tr>
<tr class="separator:ad065fd64357444d7792b80876fcfa41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0dd7bbe04f5f18dc592a11c536bb6b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8h.html#a5d0dd7bbe04f5f18dc592a11c536bb6b">minEuclideanDistance</a> (Eigen::RowVectorXd weigths, Eigen::RowVectorXd fixed, Eigen::MatrixXd data, Eigen::MatrixXd::Index &amp;maxRow)</td></tr>
<tr class="memdesc:a5d0dd7bbe04f5f18dc592a11c536bb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data multiplicando las distancias por el vector de características que las pondera.  <a href="Euclidean_8h.html#a5d0dd7bbe04f5f18dc592a11c536bb6b">Más...</a><br /></td></tr>
<tr class="separator:a5d0dd7bbe04f5f18dc592a11c536bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5825bcc562c6dabe6c136863aedeca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8h.html#a4f5825bcc562c6dabe6c136863aedeca">ManualEuclideanDistance</a> (Eigen::RowVectorXd fixed, Eigen::MatrixXd data, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:a4f5825bcc562c6dabe6c136863aedeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo manualmente.  <a href="Euclidean_8h.html#a4f5825bcc562c6dabe6c136863aedeca">Más...</a><br /></td></tr>
<tr class="separator:a4f5825bcc562c6dabe6c136863aedeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fa99f7f091464475f3aa8c1a9f13b5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8h.html#aa2fa99f7f091464475f3aa8c1a9f13b5">ManualEuclideanDistance</a> (Eigen::RowVectorXd weigths, Eigen::RowVectorXd fixed, Eigen::MatrixXd data, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:aa2fa99f7f091464475f3aa8c1a9f13b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características manualmente.  <a href="Euclidean_8h.html#aa2fa99f7f091464475f3aa8c1a9f13b5">Más...</a><br /></td></tr>
<tr class="separator:aa2fa99f7f091464475f3aa8c1a9f13b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf9d105d2e503df5b99f19eddcaca28"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8h.html#acdf9d105d2e503df5b99f19eddcaca28">ManualEuclideanDistanceType</a> (Eigen::RowVectorXd fixed, Eigen::MatrixXd data, vector&lt; char &gt;label, char type, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:acdf9d105d2e503df5b99f19eddcaca28"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo perteneciente a una clase específica manualmente.  <a href="Euclidean_8h.html#acdf9d105d2e503df5b99f19eddcaca28">Más...</a><br /></td></tr>
<tr class="separator:acdf9d105d2e503df5b99f19eddcaca28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac249d23e7dedd767338fd2733fe88c0c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8h.html#ac249d23e7dedd767338fd2733fe88c0c">ManualEuclideanDistanceType</a> (Eigen::RowVectorXd weigths, Eigen::RowVectorXd fixed, Eigen::MatrixXd data, vector&lt; char &gt;label, char type, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:ac249d23e7dedd767338fd2733fe88c0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características y perteneciente a una clase específica manualmente.  <a href="Euclidean_8h.html#ac249d23e7dedd767338fd2733fe88c0c">Más...</a><br /></td></tr>
<tr class="separator:ac249d23e7dedd767338fd2733fe88c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descripción detallada</h2>
<div class="textblock"><dl class="section version"><dt>Versión</dt><dd>2.5 </dd></dl>
<dl class="section date"><dt>Fecha</dt><dd>09/04/2022 </dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Brian Sena Simons 3ºA-A2 <div class="fragment"><div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line"> MatrixXd mat(3,2);</div>
<div class="line"> mat &lt;&lt; 1, 1,</div>
<div class="line">        2, 2,</div>
<div class="line">        4, 4;</div>
<div class="line"> </div>
<div class="line"> RowVectorXd fil = <a class="code hl_function" href="mytools_8cpp.html#a3176dc33dc79b493d699596ece0e1ef7">removeRow</a>(mat,2);</div>
<div class="line"> MatriXd::Index pos;</div>
<div class="line"> <span class="keywordtype">double</span> min = <a class="code hl_function" href="Euclidean_8h.html#ad065fd64357444d7792b80876fcfa41f">minEuclideanDistance</a>(fil,mat,pos);</div>
<div class="line"> cout &lt;&lt; <span class="stringliteral">&quot;Mínimo vecino por fila en: &quot;</span> &lt;&lt; pos &lt;&lt; <span class="stringliteral">&quot; con valor: &quot;</span> &lt;&lt; min &lt;&lt; endl;</div>
<div class="line">}</div>
<div class="ttc" id="aEuclidean_8h_html_ad065fd64357444d7792b80876fcfa41f"><div class="ttname"><a href="Euclidean_8h.html#ad065fd64357444d7792b80876fcfa41f">minEuclideanDistance</a></div><div class="ttdeci">double minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data, Eigen::MatrixXd::Index &amp;maxRow)</div><div class="ttdoc">minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...</div><div class="ttdef"><b>Definition:</b> Util_Euclidean.cpp:41</div></div>
<div class="ttc" id="amytools_8cpp_html_a3176dc33dc79b493d699596ece0e1ef7"><div class="ttname"><a href="mytools_8cpp.html#a3176dc33dc79b493d699596ece0e1ef7">removeRow</a></div><div class="ttdeci">Eigen::MatrixXd removeRow(Eigen::MatrixXd matrix, unsigned int rowToRemove)</div><div class="ttdoc">removeRow nos permite quitar una fila de una matrix de entrada (sin modificar la original) y devuelve...</div><div class="ttdef"><b>Definition:</b> mytools.cpp:126</div></div>
</div><!-- fragment --> </dd></dl>
</div><h2 class="groupheader">Documentación de las funciones</h2>
<a id="a4f5825bcc562c6dabe6c136863aedeca" name="a4f5825bcc562c6dabe6c136863aedeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5825bcc562c6dabe6c136863aedeca">&#9670;&nbsp;</a></span>ManualEuclideanDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo manualmente. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>es el vector de pesos característicos a multiplicar </td></tr>
    <tr><td class="paramname">fixed</td><td>Fila a buscar contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">pos</td><td>Fila de la que provee fixed. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo. </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="Euclidean_8h.html#ad065fd64357444d7792b80876fcfa41f" title="minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...">minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,Eigen::MatrixXd::Index &amp;maxRow)</a>;</dd></dl>
<p>Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos". </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="Euclidean_8h.html#ad065fd64357444d7792b80876fcfa41f" title="minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...">minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,Eigen::MatrixXd::Index &amp;maxRow)</a> </dd></dl>

</div>
</div>
<a id="aa2fa99f7f091464475f3aa8c1a9f13b5" name="aa2fa99f7f091464475f3aa8c1a9f13b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fa99f7f091464475f3aa8c1a9f13b5">&#9670;&nbsp;</a></span>ManualEuclideanDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características manualmente. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>es el vector de pesos característicos a multiplicar </td></tr>
    <tr><td class="paramname">fixed</td><td>Fila a buscar contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">pos</td><td>Fila de la que provee fixed. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo. </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd>double <a class="el" href="Euclidean_8h.html#a4f5825bcc562c6dabe6c136863aedeca" title="ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por ...">ManualEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,unsigned int pos,unsigned int &amp;maxRow)</a>;</dd></dl>
<p>Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen ponderado por los pesos característicos calculados y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos". </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="Euclidean_8h.html#a4f5825bcc562c6dabe6c136863aedeca" title="ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por ...">ManualEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,unsigned int pos, unsigned int &amp;maxRow)</a>; </dd></dl>

</div>
</div>
<a id="acdf9d105d2e503df5b99f19eddcaca28" name="acdf9d105d2e503df5b99f19eddcaca28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf9d105d2e503df5b99f19eddcaca28">&#9670;&nbsp;</a></span>ManualEuclideanDistanceType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistanceType </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo perteneciente a una clase específica manualmente. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>es el vector de pesos característicos a multiplicar </td></tr>
    <tr><td class="paramname">fixed</td><td>Fila a buscar contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">label</td><td>Vector de etiquetas. </td></tr>
    <tr><td class="paramname">type</td><td>Clase a buscar. </td></tr>
    <tr><td class="paramname">pos</td><td>Fila de la que provee fixed. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo. </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd>double <a class="el" href="Euclidean_8h.html#a4f5825bcc562c6dabe6c136863aedeca" title="ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por ...">ManualEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,unsigned int pos,unsigned int &amp;maxRow)</a>;</dd></dl>
<p>Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos" y verificando que sea de tipo "type" con ayuda del vector de etiquetas "label" </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="Euclidean_8h.html#a4f5825bcc562c6dabe6c136863aedeca" title="ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por ...">ManualEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,unsigned int pos, unsigned int &amp;maxRow)</a>; </dd></dl>

</div>
</div>
<a id="ac249d23e7dedd767338fd2733fe88c0c" name="ac249d23e7dedd767338fd2733fe88c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac249d23e7dedd767338fd2733fe88c0c">&#9670;&nbsp;</a></span>ManualEuclideanDistanceType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistanceType </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características y perteneciente a una clase específica manualmente. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>es el vector de pesos característicos a multiplicar </td></tr>
    <tr><td class="paramname">fixed</td><td>Fila a buscar contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">label</td><td>Vector de etiquetas. </td></tr>
    <tr><td class="paramname">type</td><td>Clase a buscar. </td></tr>
    <tr><td class="paramname">pos</td><td>Fila de la que provee fixed. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo. </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd>double <a class="el" href="Euclidean_8h.html#acdf9d105d2e503df5b99f19eddcaca28" title="ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino ...">ManualEuclideanDistanceType(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,vector&lt;char&gt;label, char type, unsigned int pos, unsigned int &amp;maxRow)</a>;</dd></dl>
<p>Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen multiplicado por el vector de características calculado, y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos" y verificando que sea de tipo "type" con ayuda del vector de etiquetas "label" </p><dl class="section see"><dt>Ver también</dt><dd>double <a class="el" href="Euclidean_8h.html#acdf9d105d2e503df5b99f19eddcaca28" title="ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino ...">ManualEuclideanDistanceType(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,
     vector&lt;char&gt; label, char type,unsigned int pos, unsigned int &amp;maxRow)</a>; </dd></dl>

</div>
</div>
<a id="ad065fd64357444d7792b80876fcfa41f" name="ad065fd64357444d7792b80876fcfa41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad065fd64357444d7792b80876fcfa41f">&#9670;&nbsp;</a></span>minEuclideanDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double minEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd::Index &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">fixed</td><td>Fila a buscar NO contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo.</dd></dl>
<p>Usando la librería Eigen sabemos que podemos restarle a una fila un vector de tipe RowVectorXd si activamos el calculo por filas con .rowwise() y además ese resultado podemos concatenarlo en vez de almacenarlo y llamar ahora a .squaredNorm() que calcula la distancia euclidea al cuadrado. Sin embargo, también hemos de decir que la queremos por filas y no por columnas. Luego a continuación hacemos una llamada a minCoeff() que busca el valor mínimo resultante de las operaciones realizadas. </p>

</div>
</div>
<a id="a5d0dd7bbe04f5f18dc592a11c536bb6b" name="a5d0dd7bbe04f5f18dc592a11c536bb6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0dd7bbe04f5f18dc592a11c536bb6b">&#9670;&nbsp;</a></span>minEuclideanDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double minEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd::Index &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data multiplicando las distancias por el vector de características que las pondera. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>es el vector de pesos característicos a multiplicar </td></tr>
    <tr><td class="paramname">fixed</td><td>Fila a buscar NO contenida en data. </td></tr>
    <tr><td class="paramname">data</td><td>Matrix de datos a verificar vecinos. </td></tr>
    <tr><td class="paramname">maxRow</td><td>es el ínidice de la fila más cercana encontrada. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Devuelve</dt><dd>el valor mínimo. </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="Euclidean_8h.html#ad065fd64357444d7792b80876fcfa41f" title="minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...">minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,Eigen::MatrixXd::Index &amp;maxRow)</a>;</dd></dl>
<p>Hacemos el calculo de la distancia euclidea al cuadrado pero ahora multiplicamos cada parámetro por su respectivo peso que pondera sus características. </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="Euclidean_8h.html#ad065fd64357444d7792b80876fcfa41f" title="minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...">minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,Eigen::MatrixXd::Index &amp;maxRow)</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
