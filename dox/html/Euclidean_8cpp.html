<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Práctica de Metaheurística: Referencia del Archivo src/Euclidean.cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Práctica de Metaheurística<span id="projectnumber">&#160;1</span>
   </div>
   <div id="projectbrief">APC Clasification Problem, Greedy vs LocalSearch</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Buscar','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Buscar');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">typedefs</a> &#124;
<a href="#func-members">Funciones</a>  </div>
  <div class="headertitle"><div class="title">Referencia del Archivo Euclidean.cpp</div></div>
</div><!--header-->
<div class="contents">

<p>Diferentes implementaciones de la distancia Euclidea según necesidades Mejor utilizada con los demás includes como <a class="el" href="mytools_8h.html" title="Herramientas definidas para la práctica.">mytools.h</a>.  
<a href="#details">Más...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="Euclidean_8h_source.html">../tools/Euclidean.h</a>&quot;</code><br />
<code>#include &quot;../inc/eigen-3.4.0/Eigen/Dense&quot;</code><br />
<code>#include &quot;../inc/random.hpp&quot;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
typedefs</h2></td></tr>
<tr class="memitem:a180f0653ebd0d5cdf633574b8c8512d3"><td class="memItemLeft" align="right" valign="top"><a id="a180f0653ebd0d5cdf633574b8c8512d3" name="a180f0653ebd0d5cdf633574b8c8512d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Random</b> = effolkronium::random_static</td></tr>
<tr class="separator:a180f0653ebd0d5cdf633574b8c8512d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Funciones</h2></td></tr>
<tr class="memitem:ad065fd64357444d7792b80876fcfa41f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8cpp.html#ad065fd64357444d7792b80876fcfa41f">minEuclideanDistance</a> (Eigen::RowVectorXd fixed, Eigen::MatrixXd data, Eigen::MatrixXd::Index &amp;maxRow)</td></tr>
<tr class="memdesc:ad065fd64357444d7792b80876fcfa41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data.  <a href="Euclidean_8cpp.html#ad065fd64357444d7792b80876fcfa41f">Más...</a><br /></td></tr>
<tr class="separator:ad065fd64357444d7792b80876fcfa41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279ce1dc36aa76d8fe48671866b53dfa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8cpp.html#a279ce1dc36aa76d8fe48671866b53dfa">minEuclideanDistance</a> (Eigen::RowVectorXd weights, Eigen::RowVectorXd fixed, Eigen::MatrixXd data, Eigen::MatrixXd::Index &amp;maxRow)</td></tr>
<tr class="memdesc:a279ce1dc36aa76d8fe48671866b53dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data multiplicando las distancias por el vector de características que las pondera.  <a href="Euclidean_8cpp.html#a279ce1dc36aa76d8fe48671866b53dfa">Más...</a><br /></td></tr>
<tr class="separator:a279ce1dc36aa76d8fe48671866b53dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5825bcc562c6dabe6c136863aedeca"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8cpp.html#a4f5825bcc562c6dabe6c136863aedeca">ManualEuclideanDistance</a> (Eigen::RowVectorXd fixed, Eigen::MatrixXd data, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:a4f5825bcc562c6dabe6c136863aedeca"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo manualmente.  <a href="Euclidean_8cpp.html#a4f5825bcc562c6dabe6c136863aedeca">Más...</a><br /></td></tr>
<tr class="separator:a4f5825bcc562c6dabe6c136863aedeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96156c8bd9722dd93ecd1c7bd62a3a7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8cpp.html#ae96156c8bd9722dd93ecd1c7bd62a3a7">ManualEuclideanDistance</a> (Eigen::RowVectorXd weights, Eigen::RowVectorXd fixed, Eigen::MatrixXd data, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:ae96156c8bd9722dd93ecd1c7bd62a3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características manualmente.  <a href="Euclidean_8cpp.html#ae96156c8bd9722dd93ecd1c7bd62a3a7">Más...</a><br /></td></tr>
<tr class="separator:ae96156c8bd9722dd93ecd1c7bd62a3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15615cc501cd57df609a342fe8cca7c2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8cpp.html#a15615cc501cd57df609a342fe8cca7c2">ManualEuclideanDistanceType</a> (Eigen::RowVectorXd fixed, Eigen::MatrixXd data, vector&lt; char &gt; label, char type, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:a15615cc501cd57df609a342fe8cca7c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo perteneciente a una clase específica manualmente.  <a href="Euclidean_8cpp.html#a15615cc501cd57df609a342fe8cca7c2">Más...</a><br /></td></tr>
<tr class="separator:a15615cc501cd57df609a342fe8cca7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435bbaf48f4140898c13da58ffa48ee4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Euclidean_8cpp.html#a435bbaf48f4140898c13da58ffa48ee4">ManualEuclideanDistanceType</a> (Eigen::RowVectorXd weights, Eigen::RowVectorXd fixed, Eigen::MatrixXd data, vector&lt; char &gt; label, char type, unsigned int pos, unsigned int &amp;maxRow)</td></tr>
<tr class="memdesc:a435bbaf48f4140898c13da58ffa48ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características y perteneciente a una clase específica manualmente.  <a href="Euclidean_8cpp.html#a435bbaf48f4140898c13da58ffa48ee4">Más...</a><br /></td></tr>
<tr class="separator:a435bbaf48f4140898c13da58ffa48ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descripción detallada</h2>
<div class="textblock"><p >Diferentes implementaciones de la distancia Euclidea según necesidades Mejor utilizada con los demás includes como <a class="el" href="mytools_8h.html" title="Herramientas definidas para la práctica.">mytools.h</a>. </p>
<dl class="section version"><dt>Versión</dt><dd>2.5 </dd></dl>
<dl class="section date"><dt>Fecha</dt><dd>09/05/2022 </dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Brian Sena Simons 3ºA-A2 <div class="fragment"><div class="line"> [...]</div>
<div class="line">  RowVectorXd Weights = VectorXd::Constant(mat.cols(),1);</div>
<div class="line">  min = <a class="code hl_function" href="Euclidean_8cpp.html#ad065fd64357444d7792b80876fcfa41f">minEuclideanDistance</a>(Weights,mat.row(0), mat.block(row,0,upper_row - row,mat.cols()),index);</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Prueba de obtención de clase concreta&quot;</span> &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Obteniendo filas tipo g &quot;</span> &lt;&lt; endl;</div>
<div class="line">  MatrixXd typeG = <a class="code hl_function" href="ReadData_8cpp.html#abdfd60b2dabf33b1de7720bceaea78dc">getClass</a>(mat,label,<span class="charliteral">&#39;g&#39;</span>);</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;Filas: &quot;</span> &lt;&lt; typeG.rows() &lt;&lt; <span class="stringliteral">&quot; columnas: &quot;</span> &lt;&lt; typeG.cols()  &lt;&lt; endl;</div>
<div class="line">  cout &lt;&lt; <span class="stringliteral">&quot;###################################&quot;</span> &lt;&lt; endl;</div>
<div class="line">[...]</div>
<div class="ttc" id="aEuclidean_8cpp_html_ad065fd64357444d7792b80876fcfa41f"><div class="ttname"><a href="Euclidean_8cpp.html#ad065fd64357444d7792b80876fcfa41f">minEuclideanDistance</a></div><div class="ttdeci">double minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data, Eigen::MatrixXd::Index &amp;maxRow)</div><div class="ttdoc">minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...</div><div class="ttdef"><b>Definition:</b> Euclidean.cpp:41</div></div>
<div class="ttc" id="aReadData_8cpp_html_abdfd60b2dabf33b1de7720bceaea78dc"><div class="ttname"><a href="ReadData_8cpp.html#abdfd60b2dabf33b1de7720bceaea78dc">getClass</a></div><div class="ttdeci">Eigen::MatrixXd getClass(Eigen::MatrixXd data, vector&lt; char &gt; Label, char type)</div><div class="ttdoc">getClass lo que nos devuelve es una matrix con los datos pertenecientes a una clase específica.</div><div class="ttdef"><b>Definition:</b> ReadData.cpp:36</div></div>
</div><!-- fragment --> </dd></dl>
</div><h2 class="groupheader">Documentación de las funciones</h2>
<a id="a4f5825bcc562c6dabe6c136863aedeca" name="a4f5825bcc562c6dabe6c136863aedeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f5825bcc562c6dabe6c136863aedeca">&#9670;&nbsp;</a></span>ManualEuclideanDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo manualmente. </p>
<p >Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos". </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="Euclidean_8cpp.html#ad065fd64357444d7792b80876fcfa41f" title="minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...">minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,Eigen::MatrixXd::Index &amp;maxRow)</a> </dd></dl>

</div>
</div>
<a id="ae96156c8bd9722dd93ecd1c7bd62a3a7" name="ae96156c8bd9722dd93ecd1c7bd62a3a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96156c8bd9722dd93ecd1c7bd62a3a7">&#9670;&nbsp;</a></span>ManualEuclideanDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características manualmente. </p>
<p >Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen ponderado por los pesos característicos calculados y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos". </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="Euclidean_8cpp.html#a4f5825bcc562c6dabe6c136863aedeca" title="ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por ...">ManualEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,unsigned int pos, unsigned int &amp;maxRow)</a>; </dd></dl>

</div>
</div>
<a id="a15615cc501cd57df609a342fe8cca7c2" name="a15615cc501cd57df609a342fe8cca7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15615cc501cd57df609a342fe8cca7c2">&#9670;&nbsp;</a></span>ManualEuclideanDistanceType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistanceType </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo perteneciente a una clase específica manualmente. </p>
<p >Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos" y verificando que sea de tipo "type" con ayuda del vector de etiquetas "label" </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="Euclidean_8cpp.html#a4f5825bcc562c6dabe6c136863aedeca" title="ManualEuclideanDistance no-utiliza completamente la librería Eigen para calcular el menor vecino por ...">ManualEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,unsigned int pos, unsigned int &amp;maxRow)</a>; </dd></dl>

</div>
</div>
<a id="a435bbaf48f4140898c13da58ffa48ee4" name="a435bbaf48f4140898c13da58ffa48ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a435bbaf48f4140898c13da58ffa48ee4">&#9670;&nbsp;</a></span>ManualEuclideanDistanceType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ManualEuclideanDistanceType </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; char &gt;&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino por fila, ya que ahora permitimos que fixed, esté contenido en data, y lo que hacemos es elegir el segundo mínimo ponderado por el vector de características y perteneciente a una clase específica manualmente. </p>
<p >Hacemos el cálculo de la distancia euclidea al cuadrado utilizando la librería Eigen multiplicado por el vector de características calculado, y ese resultado lo almacenamos en un vector resultante y iteramos sobre él en busca del segundo mínimo valor evitando que ese sea justo el de la posición especificada "pos" y verificando que sea de tipo "type" con ayuda del vector de etiquetas "label" </p><dl class="section see"><dt>Ver también</dt><dd>double <a class="el" href="Euclidean_8cpp.html#a15615cc501cd57df609a342fe8cca7c2" title="ManualEuclideanDistanceType no-utiliza completamente la librería Eigen para calcular el menor vecino ...">ManualEuclideanDistanceType(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,
     vector&lt;char&gt; label, char type,unsigned int pos, unsigned int &amp;maxRow)</a>; </dd></dl>

</div>
</div>
<a id="ad065fd64357444d7792b80876fcfa41f" name="ad065fd64357444d7792b80876fcfa41f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad065fd64357444d7792b80876fcfa41f">&#9670;&nbsp;</a></span>minEuclideanDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double minEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd::Index &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data. </p>
<p >Usando la librería Eigen sabemos que podemos restarle a una fila un vector de tipe RowVectorXd si activamos el calculo por filas con .rowwise() y además ese resultado podemos concatenarlo en vez de almacenarlo y llamar ahora a .squaredNorm() que calcula la distancia euclidea al cuadrado. Sin embargo, también hemos de decir que la queremos por filas y no por columnas. Luego a continuación hacemos una llamada a minCoeff() que busca el valor mínimo resultante de las operaciones realizadas. </p>

</div>
</div>
<a id="a279ce1dc36aa76d8fe48671866b53dfa" name="a279ce1dc36aa76d8fe48671866b53dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279ce1dc36aa76d8fe48671866b53dfa">&#9670;&nbsp;</a></span>minEuclideanDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double minEuclideanDistance </td>
          <td>(</td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVectorXd&#160;</td>
          <td class="paramname"><em>fixed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd::Index &amp;&#160;</td>
          <td class="paramname"><em>maxRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila "fixed" NO contenida en data multiplicando las distancias por el vector de características que las pondera. </p>
<p >Hacemos el calculo de la distancia euclidea al cuadrado pero ahora multiplicamos cada parámetro por su respectivo peso que pondera sus características. </p><dl class="section see"><dt>Ver también</dt><dd><a class="el" href="Euclidean_8cpp.html#ad065fd64357444d7792b80876fcfa41f" title="minEuclideanDistance utiliza la librería Eigen para calcular el menor vecino por fila desde una fila ...">minEuclideanDistance(Eigen::RowVectorXd fixed, Eigen::MatrixXd data,Eigen::MatrixXd::Index &amp;maxRow)</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generado por&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
